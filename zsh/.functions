###################### Functions #####################

unalias g 2>/dev/null

fixissues() {
  git stash
  default_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
  git checkout "$default_branch"
  git pull
  git checkout -b jap/elp-rubocop-fixes
  yarn install
  bundle install
  rubocop -a
  git add .
  git commit -m "fix: Changes to clean up Rubocop issues found"
  git push
  gh-c
}

# Use `xdg-open` if `open` command is not available
open_cmd="open"
command -v open >/dev/null 2>&1 || open_cmd="xdg-open"

# Open current branch in browser on Github
gh-b() {
  local file=${1:-""}
  local git_branch=${2:-$(git symbolic-ref --quiet --short HEAD)}
  local git_project_root=$(git config remote.origin.url | sed "s~git@\(.*\):\(.*\)~https://\1/\2~" | sed "s~\(.*\).git\$~\1~")
  local git_directory=$(git rev-parse --show-prefix)
  ${open_cmd} "${git_project_root}/tree/${git_branch}/${git_directory}${file}"
}

# Open Github compare page between current branch and default branch in browser
gh-c() {
  local git_branch=${2:-$(git symbolic-ref --quiet --short HEAD)}
  local git_project_root=$(git config remote.origin.url | sed "s~git@\(.*\):\(.*\)~https://\1/\2~" | sed "s~\(.*\).git\$~\1~")
  ${open_cmd} "${git_project_root}/compare/${git_branch}?expand=1"
}

# Change file extensions recursively in current directory
#
#   change-extension erb haml
function change-extension() {
  for f in **/*.$1; do
    mv "$f" "${f%.$1}.$2"
  done
}

# Load .env file into shell session for environment variables
function envup() {
  if [ -f .env ]; then
    while read -r line; do
      if [[ ! "$line" =~ ^[[:space:]]*# && -n "$line" ]]; then
        export "$line"
      fi
    done < <(sed '/^ *#/d' .env)
  else
    echo 'No .env file found' >&2
    return 1
  fi
}

# No arguments: `git status`
# With arguments: acts like `git`
g() {
  if [[ $# -gt 0 ]]; then
    git "$@"
  else
    git status
  fi
}

# Make directory and change into it
function mcd() {
  mkdir -p "$1" && cd "$1"
}

# Function to go up multiple directories based on the number of dots used
up() {
  local count=${#1} # Get the number of dots in the argument
  local path=""
  for ((i = 1; i <= count; i++)); do
    path+="../"
  done
  cd "$path" || return 1 # Navigate up, or return if the path is invalid
}
